<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>CHECK</title>

<!-- iOS + PWA icon -->
<link rel="icon" type="image/PNG" href="icon.PNG">
<link rel="apple-touch-icon" href="icon.PNG">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
:root{
  color-scheme: dark;
  --bg: #07070A;
  --card: rgba(255,255,255,.06);
  --border: rgba(255,255,255,.12);
  --text: #FFFFFF;
  --muted: rgba(255,255,255,.72);
  --muted2: rgba(255,255,255,.55);

  --primary: #4DA3FF;
  --primary2:#2C7DFF;
  --good: #32D583;

  --topRed: #E5484D;     /* TOP */
  --lowGreen: #2ECC71;   /* LOW */

  --shadow: 0 14px 40px rgba(0,0,0,.45);
  --radius: 18px;
  --radius2: 14px;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  font-family: ui-rounded, system-ui, -apple-system, "SF Pro Rounded", "SF Pro Display";
  background:
    radial-gradient(1200px 700px at 20% 0%, rgba(77,163,255,.22), transparent 55%),
    radial-gradient(900px 600px at 90% 15%, rgba(50,213,131,.18), transparent 55%),
    radial-gradient(900px 600px at 50% 100%, rgba(255,209,102,.12), transparent 55%),
    var(--bg);
  color: var(--text);
}

.container{
  max-width: 740px;
  margin: 0 auto;
  padding: 14px 14px 28px;
}

.header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  padding: 10px 4px 2px;
}

.brand{
  display:flex;
  align-items:center;
  gap:10px;
}
.logo{
  width:42px;height:42px;border-radius:14px;
  background: linear-gradient(135deg, rgba(77,163,255,.95), rgba(50,213,131,.9));
  box-shadow: var(--shadow);
  display:grid; place-items:center;
  font-weight:1100;
  overflow:hidden;
}
.logo img{ width:100%; height:100%; object-fit:cover; }
.brandText{
  display:flex; flex-direction:column; line-height:1.05;
}
.brandText .title{
  font-size:18px; font-weight:1100; letter-spacing:1px;
}
.brandText .sub{
  font-size:12px; color:var(--muted2);
}

.pills{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; align-items:center; }
.pill{
  padding: 8px 10px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,.05);
  border-radius: 999px;
  font-size: 12px;
  color: var(--muted);
  backdrop-filter: blur(8px);
}
.pill strong{ color: var(--text); }

.card{
  border:1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card);
  box-shadow: var(--shadow);
  padding: 14px;
  margin-top: 12px;
  backdrop-filter: blur(10px);
}

.row{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}

label.small{
  font-size:12px;
  color: var(--muted2);
}

input, button{
  border-radius: var(--radius2);
  border: 1px solid var(--border);
  background: rgba(255,255,255,.06);
  color: var(--text);
  padding: 12px 14px;
  font-size: 15px;
  outline:none;
}

input[type="number"]{ width:92px; text-align:center; }
input[type="text"]{ width:180px; }

button{
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  box-shadow: 0 10px 24px rgba(0,0,0,.18);
}
button:active{ transform: translateY(1px); opacity:.92; }

button.primary{
  border:none;
  background: linear-gradient(135deg, var(--primary), var(--primary2));
}
button.good{
  border:none;
  background: linear-gradient(135deg, rgba(50,213,131,.95), rgba(30,170,120,.95));
}
button.bad{
  border:none;
  background: linear-gradient(135deg, rgba(229,72,77,.95), rgba(170,40,55,.95));
}
button.ghost{
  background: rgba(255,255,255,.05);
}

.helper{
  font-size:12px;
  color: var(--muted2);
  margin-top: 8px;
}

table{
  width:100%;
  border-collapse: separate;
  border-spacing: 0 10px;
  margin-top: 10px;
}
thead th{
  text-align:start;
  font-size:12px;
  color: var(--muted2);
  font-weight:1000;
  padding: 0 10px;
}
tbody tr{
  background: rgba(255,255,255,.06);
  border: 1px solid var(--border);
  overflow:hidden;
}
tbody tr td{
  padding: 12px 12px;
}
tbody tr td:first-child{
  border-top-left-radius: 14px;
  border-bottom-left-radius: 14px;
}
tbody tr td:last-child{
  border-top-right-radius: 14px;
  border-bottom-right-radius: 14px;
  text-align:end;
  font-weight:1100;
}
tbody tr.top{ background: rgba(229,72,77,.25); border:1px solid rgba(229,72,77,.35); } /* TOP red */
tbody tr.low{ background: rgba(46,204,113,.22); border:1px solid rgba(46,204,113,.32); } /* LOW green */
tbody tr.out{ opacity:.35; }

.nameCell{ cursor:pointer; }
.tag{
  display:inline-block;
  padding: 2px 8px;
  margin-inline-start: 8px;
  border-radius: 999px;
  font-size: 11px;
  border: 1px solid var(--border);
  color: var(--muted);
  background: rgba(0,0,0,.15);
}

.history{
  margin-top: 12px;
  padding: 12px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.18);
  color: var(--muted);
  font-size: 13px;
  line-height: 1.45;
}

hr.sep{
  border:0;
  border-top:1px solid var(--border);
  margin: 12px 0;
}

/* Splash */
#splash{
  display:none;
  position:fixed;
  inset:0;
  z-index:9998;
  background: rgba(0,0,0,.55);
  backdrop-filter: blur(10px);
}
#splash .box{
  max-width: 520px;
  margin: 18vh auto;
  padding: 18px;
  border-radius: 22px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,.08);
  box-shadow: var(--shadow);
  text-align:center;
}
#splash .big{
  font-size: 52px;
  font-weight: 1200;
  letter-spacing: 2px;
  background: linear-gradient(135deg, rgba(77,163,255,.95), rgba(50,213,131,.95));
  -webkit-background-clip:text;
  background-clip:text;
  color: transparent;
}
#splash .tiny{
  margin-top: 6px;
  color: var(--muted);
  font-size: 13px;
}

/* Score Modal (Keypad) */
#scoreModal{ display:none; position:fixed; inset:0; z-index:9999; background:rgba(0,0,0,.70); backdrop-filter: blur(10px); }
#scoreModal .panel{
  max-width: 560px;
  margin: 8vh auto;
  padding: 16px;
  border-radius: 22px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,.08);
  box-shadow: var(--shadow);
}
#scoreModal .topline{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
#scoreModal .pname{ font-size: 18px; font-weight: 1200; }
#scoreModal .pinfo{ font-size: 12px; color: var(--muted2); margin-top:4px; }
#scoreModal .roundBadge{
  font-size: 12px; color: var(--muted);
  border: 1px solid var(--border);
  padding: 8px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,.18);
}
#scoreModal .scoreRow{ margin-top: 14px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
#scoreModal #mPoints{
  flex:1;
  font-size: 38px;
  font-weight: 1200;
  text-align:center;
  background: rgba(0,0,0,.25);
}
#scoreModal #mX2{
  min-width: 120px;
  font-weight: 1100;
}
#scoreModal #mX2.on{
  border:none;
  background: linear-gradient(135deg, rgba(50,213,131,.95), rgba(30,170,120,.95));
}
#scoreModal .kpGrid{
  margin-top: 14px;
  display:grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}
#scoreModal .kp{
  padding: 14px 12px;
  border-radius: 16px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.18);
  font-size: 22px;
  font-weight: 1200;
}
#scoreModal .kp:active{ transform: translateY(1px); opacity:.9; }
#scoreModal .actions{ margin-top: 14px; display:flex; gap:10px; flex-wrap:wrap; }
#scoreModal .actions button{ flex: 1; }

/* Name Modal (Playful) */
#nameModal{
  display:none;
  position:fixed;
  inset:0;
  z-index:10000;
  background:rgba(0,0,0,.70);
  backdrop-filter: blur(10px);
}
#nameModal .panel{
  max-width:520px;
  margin:18vh auto;
  padding:16px;
  border-radius:22px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.08);
  box-shadow: var(--shadow);
}
#nameModal .topline{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
#nameModal .nmTitle{ font-size:18px; font-weight:1200; }
#nameModal .nmSub{ font-size:12px; color:var(--muted2); margin-top:4px; }
#nameModal .nmInput{
  width:100%;
  font-size:18px;
  font-weight:1100;
  padding:14px;
  border-radius:16px;
  background:rgba(0,0,0,.25);
}
#nameModal .actions{ margin-top:14px; display:flex; gap:10px; flex-wrap:wrap; }
#nameModal .actions button{ flex:1; }

/* Viewer-only lock overlay */
#viewerLock{
  display:none;
  position:fixed;
  inset:0;
  z-index:10001;
  pointer-events:none;
}
#viewerLock .toast{
  pointer-events:none;
  max-width: 740px;
  margin: 10px auto 0;
  padding: 10px 14px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.35);
  color: var(--muted);
  backdrop-filter: blur(10px);
  text-align:center;
  font-size: 12px;
  font-weight: 900;
}
</style>
</head>

<body>
<div class="container">

  <div class="header">
    <div class="brand">
      <div class="logo">
        <!-- App logo in header -->
        <img src="icon.PNG" alt="CHECK">
      </div>
      <div class="brandText">
        <div class="title">CHECK</div>
        <div class="sub" id="brandSub">Scoreboard</div>
      </div>
    </div>

    <div class="pills">
      <div class="pill" id="pillRole">Role: <strong>Host</strong></div>
      <div class="pill" id="pillMode"><strong>Local</strong></div>
      <div class="pill" id="pillRoom">Room: <strong>â€”</strong></div>
    </div>
  </div>

  <!-- Setup (HOST only; hidden for viewers) -->
  <div class="card" id="setupCard">
    <div class="row">
      <div style="flex:1; min-width:200px">
        <label class="small" id="lblPlayers">Players</label><br>
        <input id="playersCount" type="number" min="2" max="10" value="2">
      </div>
      <button class="primary" id="btnStart" style="flex:1; min-width:220px;">Start Game</button>
    </div>

    <hr class="sep">

    <div class="row">
      <label class="small" id="lblLang">Language</label>
      <button class="ghost" id="btnAR">AR</button>
      <button class="ghost" id="btnEN">EN</button>
    </div>

    <div class="helper" id="tip">
      Auto-save is on. Set a Room to play live with friends.
    </div>
  </div>

  <!-- Game -->
  <div class="card" id="gameCard" style="display:none">
    <div class="row" id="hostControls">
      <button class="primary" id="btnAddRound">â• Add Round</button>
      <button class="ghost" id="btnAddPlayer">ğŸ‘¤ Add Player</button>
      <button class="ghost" id="btnReset">ğŸ”„ Reset</button>
      <button class="ghost" id="btnGoSetup">âš™ï¸ Setup</button>
      <button class="ghost" id="btnNewGame">ğŸ†• New Game</button>
    </div>

    <hr class="sep" id="hostSep">

    <div class="row" id="hostSettings">
      <div style="flex:1; min-width:220px">
        <label class="small" id="lblKick">Kick-out at</label><br>
        <input id="target" type="number" min="1" value="100">
        <div class="helper" id="lblHint">Players become OUT when total â‰¥ target.</div>
      </div>

      <div style="flex:1; min-width:260px">
        <label class="small" id="lblRoom">Room</label><br>
        <div class="row">
          <input id="roomInput" type="text" placeholder="majlis1" autocapitalize="none" autocomplete="off">
          <button class="good" id="btnSetRoom">Set</button>
          <button class="ghost" id="btnShareRoom">Share</button>
        </div>
        <div class="helper" id="roomHelp">Share the VIEW link so players only see the scoreboard.</div>
      </div>
    </div>

    <table>
      <thead>
        <tr>
          <th id="thPlayer">Player</th>
          <th id="thTotal">Total</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <div class="history" id="history"></div>
  </div>

</div>

<!-- Viewer lock toast -->
<div id="viewerLock">
  <div class="toast">VIEW MODE â€” scoreboard only (controlled by host)</div>
</div>

<!-- Splash -->
<div id="splash">
  <div class="box">
    <div class="big">CHECK</div>
    <div class="tiny" id="splashText">Letâ€™s play âœ¨</div>
  </div>
</div>

<!-- Score Modal (Host only) -->
<div id="scoreModal">
  <div class="panel">
    <div class="topline">
      <div>
        <div class="pname" id="mPlayer"></div>
        <div class="pinfo" id="mInfo"></div>
      </div>
      <div class="roundBadge" id="mRound"></div>
    </div>

    <div class="scoreRow">
      <input id="mPoints" readonly value="0" />
      <button class="ghost" id="mX2">Ã—2 OFF</button>
    </div>

    <div class="kpGrid" id="mKeypad">
      <button class="kp" data-k="1">1</button>
      <button class="kp" data-k="2">2</button>
      <button class="kp" data-k="3">3</button>
      <button class="kp" data-k="4">4</button>
      <button class="kp" data-k="5">5</button>
      <button class="kp" data-k="6">6</button>
      <button class="kp" data-k="7">7</button>
      <button class="kp" data-k="8">8</button>
      <button class="kp" data-k="9">9</button>
      <button class="kp" data-k="clear">C</button>
      <button class="kp" data-k="0">0</button>
      <button class="kp" data-k="back">âŒ«</button>
    </div>

    <div class="actions">
      <button class="primary" id="mNext">Next</button>
      <button class="ghost" id="mSkip">Skip</button>
      <button class="ghost" id="mCancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Name Modal (Host only) -->
<div id="nameModal">
  <div class="panel">
    <div class="topline">
      <div>
        <div class="nmTitle" id="nmTitle">Name</div>
        <div class="nmSub" id="nmSub">Type a fun name âœ¨</div>
      </div>
      <div class="logo"><img src="icon.PNG" alt="CHECK"></div>
    </div>

    <div style="margin-top:14px;">
      <input id="nmInput" class="nmInput" type="text" autocapitalize="words" autocomplete="off" placeholder="Player 1" />
    </div>

    <div class="actions">
      <button class="primary" id="nmSave">Save</button>
      <button class="ghost" id="nmCancel">Cancel</button>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /* ========= Firebase (your config) ========= */
  const FIREBASE_ENABLED = true;
  const firebaseConfig = {
    apiKey: "AIzaSyC0twO6-07rT8NNwqVOlLDpwRIakjC122Y",
    authDomain: "ceck-21719.firebaseapp.com",
    databaseURL: "https://ceck-21719-default-rtdb.firebaseio.com",
    projectId: "ceck-21719",
    storageBucket: "ceck-21719.firebasestorage.app",
    messagingSenderId: "747335920443",
    appId: "1:747335920443:web:d65ff3f8ed4b801e3a651e",
    measurementId: "G-N68P7BHP86"
  };

  /* ========= DOM ========= */
  const $ = (id) => document.getElementById(id);

  const el = {
    setupCard: $("setupCard"),
    gameCard: $("gameCard"),
    playersCount: $("playersCount"),
    btnStart: $("btnStart"),
    btnAR: $("btnAR"),
    btnEN: $("btnEN"),

    hostControls: $("hostControls"),
    hostSettings: $("hostSettings"),
    hostSep: $("hostSep"),

    btnAddRound: $("btnAddRound"),
    btnAddPlayer: $("btnAddPlayer"),
    btnReset: $("btnReset"),
    btnGoSetup: $("btnGoSetup"),
    btnNewGame: $("btnNewGame"),

    target: $("target"),
    roomInput: $("roomInput"),
    btnSetRoom: $("btnSetRoom"),
    btnShareRoom: $("btnShareRoom"),

    tbody: $("tbody"),
    history: $("history"),

    pillRole: $("pillRole"),
    pillMode: $("pillMode"),
    pillRoom: $("pillRoom"),

    brandSub: $("brandSub"),

    lblPlayers: $("lblPlayers"),
    lblLang: $("lblLang"),
    tip: $("tip"),
    lblKick: $("lblKick"),
    lblHint: $("lblHint"),
    lblRoom: $("lblRoom"),
    roomHelp: $("roomHelp"),
    thPlayer: $("thPlayer"),
    thTotal: $("thTotal"),

    splash: $("splash"),
    splashText: $("splashText"),

    viewerLock: $("viewerLock"),

    // score modal
    scoreModal: $("scoreModal"),
    mPlayer: $("mPlayer"),
    mInfo: $("mInfo"),
    mRound: $("mRound"),
    mPoints: $("mPoints"),
    mX2: $("mX2"),
    mKeypad: $("mKeypad"),
    mNext: $("mNext"),
    mSkip: $("mSkip"),
    mCancel: $("mCancel"),

    // name modal
    nameModal: $("nameModal"),
    nmTitle: $("nmTitle"),
    nmSub: $("nmSub"),
    nmInput: $("nmInput"),
    nmSave: $("nmSave"),
    nmCancel: $("nmCancel"),
  };

  /* ========= Role: host vs viewer =========
     - Host uses: ?host=1 OR no role specified (default host on your phone)
     - Viewer uses: ?view=1 (share this link with players)
  */
  const spBoot = new URLSearchParams(location.search);
  const IS_VIEWER = spBoot.get("view") === "1";
  const IS_HOST = !IS_VIEWER; // simple + reliable

  /* ========= i18n ========= */
  const I18N = {
    ar: {
      brandSub: "Ù„ÙˆØ­Ø© Ø§Ù„Ù†Ù‚Ø§Ø·",
      setupTip: "Ø§Ù„Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§. Ø­Ø¯Ù‘Ø¯ Room Ù„Ù„Ø¹Ø¨ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù…Ø¹ Ø£ØµØ¯Ù‚Ø§Ø¦Ùƒ.",
      players: "Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†",
      start: "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©",
      lang: "Ø§Ù„Ù„ØºØ©",
      kick: "Ø§Ù„Ø¥Ù‚ØµØ§Ø¡ Ø¹Ù†Ø¯",
      hint: "ÙŠØµØ¨Ø­ Ø§Ù„Ù„Ø§Ø¹Ø¨ OUT Ø¹Ù†Ø¯Ù…Ø§ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ â‰¥ Ø§Ù„Ù‡Ø¯Ù.",
      room: "Room",
      roomHelp: "Ø§Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· VIEW Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† (ÙŠØ´ÙˆÙÙˆÙ† Ø§Ù„Ù„ÙˆØ­Ø© ÙÙ‚Ø·).",
      addRound: "â• Ø¬ÙˆÙ„Ø©",
      addPlayer: "ğŸ‘¤ Ù„Ø§Ø¹Ø¨",
      reset: "ğŸ”„ ØªØµÙÙŠØ±",
      setup: "âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
      newGame: "ğŸ†• Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©",
      thPlayer: "Ø§Ù„Ù„Ø§Ø¹Ø¨",
      thTotal: "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹",
      out: "OUT",
      maxPlayers: "Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 10 Ù„Ø§Ø¹Ø¨ÙŠÙ†.",
      confirmReset: "ØªØµÙÙŠØ± ÙƒÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø¬Ù…ÙŠØ¹ INØŸ",
      confirmNew: "Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©ØŸ (Ø³ÙŠØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø­Ø§Ù„ÙŠ)",
      splash: "Letâ€™s play âœ¨",
      local: "Local",
      live: "Live",
      setRoomFirst: "Ø§ÙƒØªØ¨ Room Ø£ÙˆÙ„Ø§Ù‹",
      copied: "ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø·",
      modalNext: "Ø§Ù„ØªØ§Ù„ÙŠ",
      modalSkip: "ØªØ®Ø·ÙŠ",
      modalCancel: "Ø¥Ù„ØºØ§Ø¡",
      modalRound: "Ø¬ÙˆÙ„Ø©",
      modalTotal: "Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø§Ù„Ø­Ø§Ù„ÙŠ",
      nmTitleAdd: "Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨",
      nmTitleEdit: "ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø§Ø³Ù…",
      nmSub: "Ø§Ø®ØªØ± Ø§Ø³Ù… Ù„Ø·ÙŠÙ âœ¨",
      nmSave: "Ø­ÙØ¸",
      nmCancel: "Ø¥Ù„ØºØ§Ø¡",
      roleHost: "Host",
      roleView: "Viewer",
      viewToast: "ÙˆØ¶Ø¹ Ø§Ù„Ø¹Ø±Ø¶ â€” Ø§Ù„Ù„ÙˆØ­Ø© ÙÙ‚Ø· (Ø§Ù„ØªØ­ÙƒÙ… Ø¹Ù†Ø¯ Ø§Ù„Ù‡ÙˆØ³Øª)",
      shareText: "Share VIEW",
    },
    en: {
      brandSub: "Scoreboard",
      setupTip: "Auto-save is on. Set a Room to play live with friends.",
      players: "Players",
      start: "Start Game",
      lang: "Language",
      kick: "Kick-out at",
      hint: "Players become OUT when total â‰¥ target.",
      room: "Room",
      roomHelp: "Share the VIEW link so players only see the scoreboard.",
      addRound: "â• Add Round",
      addPlayer: "ğŸ‘¤ Add Player",
      reset: "ğŸ”„ Reset",
      setup: "âš™ï¸ Setup",
      newGame: "ğŸ†• New Game",
      thPlayer: "Player",
      thTotal: "Total",
      out: "OUT",
      maxPlayers: "Max players is 10.",
      confirmReset: "Reset all totals and set everyone IN?",
      confirmNew: "Start a new game? (clears current)",
      splash: "Letâ€™s play âœ¨",
      local: "Local",
      live: "Live",
      setRoomFirst: "Enter a room first",
      copied: "VIEW link copied",
      modalNext: "Next",
      modalSkip: "Skip",
      modalCancel: "Cancel",
      modalRound: "Round",
      modalTotal: "Current total",
      nmTitleAdd: "Player name",
      nmTitleEdit: "Edit name",
      nmSub: "Pick a fun name âœ¨",
      nmSave: "Save",
      nmCancel: "Cancel",
      roleHost: "Host",
      roleView: "Viewer",
      viewToast: "VIEW MODE â€” scoreboard only (controlled by host)",
      shareText: "Share VIEW",
    }
  };

  /* ========= Storage ========= */
  const KEY = "check_app_v3_state";
  const KEY_ROOM = "check_app_v3_room";
  const KEY_CID = "check_app_v3_client";

  let clientId = localStorage.getItem(KEY_CID);
  if(!clientId){
    clientId = "c_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
    localStorage.setItem(KEY_CID, clientId);
  }

  let room = localStorage.getItem(KEY_ROOM) || "";

  let state = {
    lang: "en",
    names: [],
    totals: [],
    out: [],
    history: [],
    target: 100
  };

  function t(k){
    const pack = I18N[state.lang] || I18N.en;
    return pack[k] ?? I18N.en[k] ?? k;
  }

  function saveLocal(){
    // viewers should not overwrite host changes
    if(IS_VIEWER) return;
    state.target = Math.max(1, Math.floor(Number(el.target.value) || state.target || 100));
    localStorage.setItem(KEY, JSON.stringify(state));
  }

  function loadLocal(){
    try{
      const raw = localStorage.getItem(KEY);
      if(raw) state = { ...state, ...JSON.parse(raw) };
    }catch{}
  }

  function cleanRoom(s){
    return (s||"").trim().toLowerCase().replace(/[^a-z0-9_-]/g,"").slice(0,24);
  }

  /* ========= UI ========= */
  function applyLang(){
    document.documentElement.lang = state.lang;
    document.documentElement.dir  = (state.lang === "ar") ? "rtl" : "ltr";

    el.brandSub.textContent = t("brandSub");
    el.tip.textContent = t("setupTip");

    el.lblPlayers.textContent = t("players");
    el.btnStart.textContent = t("start");
    el.lblLang.textContent = t("lang");

    el.lblKick.textContent = t("kick");
    el.lblHint.textContent = t("hint");

    el.lblRoom.textContent = t("room");
    el.roomHelp.textContent = t("roomHelp");

    el.btnShareRoom.textContent = t("shareText");

    el.btnAddRound.textContent = t("addRound");
    el.btnAddPlayer.textContent = t("addPlayer");
    el.btnReset.textContent = t("reset");
    el.btnGoSetup.textContent = t("setup");
    el.btnNewGame.textContent = t("newGame");

    el.thPlayer.textContent = t("thPlayer");
    el.thTotal.textContent = t("thTotal");

    el.splashText.textContent = t("splash");

    el.mNext.textContent = t("modalNext");
    el.mSkip.textContent = t("modalSkip");
    el.mCancel.textContent = t("modalCancel");

    el.nmSub.textContent = t("nmSub");
    el.nmSave.textContent = t("nmSave");
    el.nmCancel.textContent = t("nmCancel");

    el.viewerLock.querySelector(".toast").textContent = t("viewToast");

    updatePills();
    applyRoleUI();
  }

  function applyRoleUI(){
    el.pillRole.innerHTML = `Role: <strong>${IS_VIEWER ? t("roleView") : t("roleHost")}</strong>`;

    if(IS_VIEWER){
      // hide all controls + setup, show only scoreboard
      el.setupCard.style.display = "none";
      el.hostControls.style.display = "none";
      el.hostSettings.style.display = "none";
      el.hostSep.style.display = "none";
      el.history.style.display = "none"; // viewers: no history (scoreboard only)
      el.viewerLock.style.display = "block";

      // prevent keyboard focus
      el.roomInput.setAttribute("disabled","disabled");
      el.target.setAttribute("disabled","disabled");
      el.playersCount.setAttribute("disabled","disabled");
      el.btnStart.style.display = "none";
      el.btnAR.style.display = "none";
      el.btnEN.style.display = "none";
      el.btnSetRoom.style.display = "none";
      // share still ok from host, but viewer doesn't need it
      el.btnShareRoom.style.display = "none";
    }else{
      el.viewerLock.style.display = "none";
      el.btnShareRoom.style.display = "";
    }
  }

  function updatePills(){
    const liveOk = firebaseReady && room;
    el.pillMode.innerHTML = `<strong>${liveOk ? t("live") : t("local")}</strong>`;
    el.pillRoom.innerHTML = `Room: <strong>${room ? room : "â€”"}</strong>`;
  }

  function showSetup(){
    if(IS_VIEWER){
      // viewer should never see setup
      el.setupCard.style.display = "none";
      return;
    }
    el.setupCard.style.display = "";
    el.gameCard.style.display = "none";
  }

  function showGame(){
    el.setupCard.style.display = "none";
    el.gameCard.style.display = "";
    el.target.value = state.target || 100;
    el.roomInput.value = room || "";
    render();
  }

  function showSplash(){
    if(IS_VIEWER) return;
    el.splash.style.display = "block";
    setTimeout(()=>{ el.splash.style.display = "none"; }, 900);
  }

  function computeTopLow(){
    const inIdx = state.totals.map((_,i)=>i).filter(i => !state.out[i]);
    if(inIdx.length === 0) return {top:-1, low:-1, allEqual:true};
    let top = inIdx[0], low = inIdx[0];
    for(const i of inIdx){
      if(state.totals[i] > state.totals[top]) top = i;
      if(state.totals[i] < state.totals[low]) low = i;
    }
    const allEqual = inIdx.every(i => state.totals[i] === state.totals[inIdx[0]]);
    return {top, low, allEqual};
  }

  function render(){
    el.tbody.innerHTML = "";
    const {top, low, allEqual} = computeTopLow();

    state.names.forEach((name,i)=>{
      const tr = document.createElement("tr");
      if(state.out[i]) tr.classList.add("out");
      if(!state.out[i] && !allEqual && i===top) tr.classList.add("top"); // TOP red
      if(!state.out[i] && !allEqual && i===low) tr.classList.add("low"); // LOW green

      const td1 = document.createElement("td");
      td1.className = "nameCell";
      td1.textContent = name;

      // host can edit names by tapping
      if(IS_HOST){
        td1.onclick = ()=>editName(i);
      }else{
        td1.onclick = null;
        td1.style.cursor = "default";
      }

      if(state.out[i]){
        const tag = document.createElement("span");
        tag.className="tag";
        tag.textContent = t("out");
        td1.appendChild(tag);
      }

      const td2 = document.createElement("td");
      td2.textContent = String(state.totals[i] ?? 0);

      tr.appendChild(td1);
      tr.appendChild(td2);
      el.tbody.appendChild(tr);
    });

    // history hidden for viewers by role UI, but keep content updated for host
    el.history.innerHTML = (state.history || []).slice(0,12).map(h => "â€¢ " + h).join("<br>");
  }

  /* ========= Name Modal ========= */
  function openNameModal({ title, placeholder, initialValue }){
    return new Promise((resolve)=>{
      el.nmTitle.textContent = title || "Name";
      el.nmInput.placeholder = placeholder || "";
      el.nmInput.value = initialValue || "";

      const close = (val) => {
        el.nameModal.style.display = "none";
        el.nmSave.onclick = null;
        el.nmCancel.onclick = null;
        resolve(val);
      };

      el.nmSave.onclick = () => {
        const v = (el.nmInput.value || "").trim();
        close(v.length ? v : null);
      };
      el.nmCancel.onclick = () => close(null);

      el.nameModal.style.display = "block";
      setTimeout(()=> el.nmInput.focus(), 50);
    });
  }

  async function editName(i){
    if(IS_VIEWER) return;
    const val = await openNameModal({
      title: t("nmTitleEdit"),
      placeholder: state.names[i],
      initialValue: state.names[i]
    });
    if(!val) return;
    state.names[i] = val;
    saveLocal();
    render();
    pushRemoteDebounced(true);
  }

  /* ========= Score Modal (Keypad + per-round x2 toggle) ========= */
  function openScoreModalKeypad({playerName, playerTotal, roundNo}){
    return new Promise((resolve)=>{
      let x2 = false;
      let valueStr = "0";

      const setValue = (s)=>{
        s = String(s||"").replace(/[^\d]/g,"");
        if(s.length === 0) s = "0";
        if(s.length > 1) s = s.replace(/^0+/, "") || "0";
        valueStr = s;
        el.mPoints.value = valueStr;
      };

      const setX2 = (v)=>{
        x2 = v;
        el.mX2.textContent = x2 ? "Ã—2 ON" : "Ã—2 OFF";
        el.mX2.classList.toggle("on", x2);
      };

      el.mPlayer.textContent = playerName;
      el.mInfo.textContent = `${t("modalTotal")}: ${playerTotal}`;
      el.mRound.textContent = `${t("modalRound")} ${roundNo}`;

      setValue("0");
      setX2(false);

      const close = (res)=>{
        el.scoreModal.style.display = "none";
        el.mX2.onclick = null;
        el.mKeypad.onclick = null;
        el.mNext.onclick = null;
        el.mSkip.onclick = null;
        el.mCancel.onclick = null;
        resolve(res);
      };

      el.mX2.onclick = ()=> setX2(!x2);

      el.mKeypad.onclick = (e)=>{
        const btn = e.target.closest("button.kp");
        if(!btn) return;
        const k = btn.getAttribute("data-k");
        if(k === "clear") return setValue("0");
        if(k === "back")  return setValue(valueStr.length<=1 ? "0" : valueStr.slice(0,-1));
        if(/^\d$/.test(k)){
          if(valueStr === "0") setValue(k);
          else setValue(valueStr + k);
        }
      };

      el.mNext.onclick = ()=>{
        let pts = Number(valueStr) || 0;
        if(x2) pts *= 2; // per-player option
        close({action:"ok", points: pts});
      };
      el.mSkip.onclick = ()=> close({action:"skip"});
      el.mCancel.onclick = ()=> close({action:"cancel"});

      el.scoreModal.style.display = "block";
    });
  }

  /* ========= Game logic ========= */
  function newGame(n){
    state.names = Array.from({length:n}, (_,i)=>`Player ${i+1}`);
    state.totals = Array(n).fill(0);
    state.out = Array(n).fill(false);
    state.history = [];
    saveLocal();
  }

  async function startGame(){
    if(IS_VIEWER) return;
    const n = Math.max(2, Math.min(10, Math.floor(Number(el.playersCount.value)||2)));
    newGame(n);

    // playful name modal for each player
    for(let i=0;i<state.names.length;i++){
      const val = await openNameModal({
        title: t("nmTitleAdd") + ` ${i+1}`,
        placeholder: state.names[i],
        initialValue: state.names[i]
      });
      if(val) state.names[i] = val;
    }

    saveLocal();
    applyLang();
    showGame();
    showSplash();
    pushRemoteDebounced(true);
  }

  async function addRound(){
    if(IS_VIEWER) return;
    const inIdx = state.names.map((_,i)=>i).filter(i=>!state.out[i]);
    if(inIdx.length===0) return;

    state.target = Math.max(1, Math.floor(Number(el.target.value)||state.target||100));
    const roundNo = (state.history?.length || 0) + 1;
    const changes = [];

    for(const i of inIdx){
      const res = await openScoreModalKeypad({
        playerName: state.names[i],
        playerTotal: state.totals[i],
        roundNo
      });

      if(!res || res.action==="cancel") return;

      if(res.action==="skip"){
        changes.push(`${state.names[i]} +0`);
        continue;
      }

      const pts = res.points || 0;
      state.totals[i] += pts;
      changes.push(`${state.names[i]} +${pts}`);

      if(state.totals[i] >= state.target) state.out[i] = true;
    }

    state.history.unshift(`${t("modalRound")}: ${changes.join(", ")}`);
    saveLocal();
    render();
    pushRemoteDebounced(true);
  }

  async function addPlayer(){
    if(IS_VIEWER) return;
    if(state.names.length >= 10) return alert(t("maxPlayers"));

    const defaultName = `Player ${state.names.length+1}`;
    const val = await openNameModal({
      title: t("nmTitleAdd"),
      placeholder: defaultName,
      initialValue: defaultName
    });

    const name = val || defaultName;
    state.names.push(name);
    state.totals.push(0);
    state.out.push(false);

    saveLocal();
    render();
    pushRemoteDebounced(true);
  }

  function resetTotals(){
    if(IS_VIEWER) return;
    if(!confirm(t("confirmReset"))) return;
    state.totals = state.totals.map(()=>0);
    state.out = state.out.map(()=>false);
    state.history = [];
    saveLocal();
    render();
    pushRemoteDebounced(true);
  }

  /* ========= Live Share (Firebase RTDB) ========= */
  let firebaseReady = false;
  let firebaseDb = null;
  let listenerRef = null;
  let writeTimer = null;
  let lastAppliedTs = 0;

  function loadScript(src){
    return new Promise((resolve,reject)=>{
      const s = document.createElement("script");
      s.src = src;
      s.async = true;
      s.onload = resolve;
      s.onerror = reject;
      document.head.appendChild(s);
    });
  }

  async function ensureFirebase(){
    if(!FIREBASE_ENABLED) return false;
    if(firebaseReady && firebaseDb) return true;
    try{
      await loadScript("https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js");
      await loadScript("https://www.gstatic.com/firebasejs/10.12.5/firebase-database-compat.js");

      if(!firebase.apps || firebase.apps.length===0){
        firebase.initializeApp(firebaseConfig);
      }
      firebaseDb = firebase.database();
      firebaseReady = true;
      updatePills();
      return true;
    }catch{
      firebaseReady = false;
      firebaseDb = null;
      updatePills();
      return false;
    }
  }

  function roomPath(r){ return `rooms/${r}/state`; }

  function attachListener(){
    if(!firebaseReady || !firebaseDb || !room) return;
    if(listenerRef){ listenerRef.off(); listenerRef=null; }
    listenerRef = firebaseDb.ref(roomPath(room));

    listenerRef.on("value", snap=>{
      const remote = snap.val();
      if(!remote || typeof remote !== "object") return;
      if(remote._by === clientId) return;

      const ts = Number(remote._ts || 0);
      if(ts <= lastAppliedTs) return;
      lastAppliedTs = ts;

      state.lang = (remote.lang==="ar"||remote.lang==="en") ? remote.lang : state.lang;
      state.names = Array.isArray(remote.names) ? remote.names : state.names;
      state.totals = Array.isArray(remote.totals) ? remote.totals : state.totals;
      state.out = Array.isArray(remote.out) ? remote.out : state.out;
      state.history = Array.isArray(remote.history) ? remote.history : state.history;
      state.target = Number.isFinite(remote.target) ? remote.target : state.target;

      // reflect target in UI
      el.target.value = state.target || 100;

      // viewers should never write, only render
      if(IS_HOST) localStorage.setItem(KEY, JSON.stringify(state));

      applyLang();
      render();
      updatePills();
    });

    updatePills();
  }

  function pushRemoteDebounced(force=false){
    if(IS_VIEWER) return;
    clearTimeout(writeTimer);
    writeTimer = setTimeout(()=>pushRemote(force), 220);
  }

  async function pushRemote(force=false){
    if(IS_VIEWER) return;
    if(!room) return;
    const ok = await ensureFirebase();
    if(!ok) return;

    const payload = {
      lang: state.lang,
      names: state.names,
      totals: state.totals,
      out: state.out,
      history: state.history,
      target: Math.max(1, Math.floor(Number(el.target.value)||state.target||100)),
      _by: clientId,
      _ts: Date.now()
    };

    firebaseDb.ref(roomPath(room)).set(payload).catch(()=>{});
    updatePills();
  }

  async function setRoom(){
    if(IS_VIEWER) return;

    const r = cleanRoom(el.roomInput.value);
    if(!r){
      room = "";
      localStorage.removeItem(KEY_ROOM);
      updatePills();
      if(listenerRef){ listenerRef.off(); listenerRef=null; }
      return;
    }

    room = r;
    localStorage.setItem(KEY_ROOM, room);
    el.roomInput.value = room;

    const ok = await ensureFirebase();
    if(!ok){ updatePills(); return; }

    attachListener();
    pushRemoteDebounced(true);
  }

  function makeViewLink(){
    const url = new URL(location.href);
    url.searchParams.set("room", room);
    url.searchParams.set("lang", state.lang);
    url.searchParams.set("view", "1"); // viewer mode
    // ensure host param is not set
    url.searchParams.delete("host");
    return url.toString();
  }

  async function shareRoom(){
    if(IS_VIEWER) return;
    if(!room) return alert(t("setRoomFirst"));
    const link = makeViewLink();

    if(navigator.share){
      try{ await navigator.share({ title:"CHECK", text: link, url: link }); }catch{}
    }else{
      try{ await navigator.clipboard.writeText(link); alert(t("copied")); }
      catch{ prompt("Copy VIEW link", link); }
    }
  }

  /* ========= Events ========= */
  // Host-only buttons
  el.btnStart.onclick = startGame;
  el.btnAddRound.onclick = addRound;
  el.btnAddPlayer.onclick = addPlayer;
  el.btnReset.onclick = resetTotals;

  el.btnGoSetup.onclick = ()=> { if(!IS_VIEWER) showSetup(); };
  el.btnNewGame.onclick = ()=> {
    if(IS_VIEWER) return;
    if(confirm(t("confirmNew"))){
      // clear current game
      state.names = [];
      state.totals = [];
      state.out = [];
      state.history = [];
      saveLocal();
      pushRemoteDebounced(true);
      showSetup();
    }
  };

  // Language
  el.btnAR.onclick = ()=>{ if(IS_VIEWER) return; state.lang="ar"; saveLocal(); applyLang(); render(); pushRemoteDebounced(true); };
  el.btnEN.onclick = ()=>{ if(IS_VIEWER) return; state.lang="en"; saveLocal(); applyLang(); render(); pushRemoteDebounced(true); };

  // Kick-out target
  el.target.onchange = ()=>{
    if(IS_VIEWER) return;
    state.target = Math.max(1, Math.floor(Number(el.target.value)||100));
    state.out = state.totals.map(x => (Number(x)||0) >= state.target);
    saveLocal();
    render();
    pushRemoteDebounced(true);
  };

  // Room
  el.btnSetRoom.onclick = setRoom;
  el.btnShareRoom.onclick = shareRoom;

  /* ========= Boot ========= */
  loadLocal();

  // URL params: room/lang + viewer mode
  try{
    const sp = new URLSearchParams(location.search);
    const r = cleanRoom(sp.get("room"));
    const l = sp.get("lang");

    if(l === "ar" || l === "en") state.lang = l;

    // If viewer opens with room in URL, use it (do not store permanently unless you want)
    if(r){
      room = r;
      // keep local room so reload works
      localStorage.setItem(KEY_ROOM, room);
    }
  }catch{}

  // Apply role UI and language first
  applyLang();

  // Show game if we already have state, otherwise setup for host
  if(state.names && state.names.length >= 2){
    showGame();
  }else{
    showSetup();
  }

  el.roomInput.value = room || "";
  updatePills();

  // If viewer: always show game card (scoreboard) even if empty
  if(IS_VIEWER){
    el.gameCard.style.display = "";
    el.setupCard.style.display = "none";
  }

  // Auto-connect to firebase when room exists (viewer or host)
  if(room){
    ensureFirebase().then(ok=>{
      if(ok) attachListener();
      updatePills();
    });
  }
})();
</script>
</body>
</html>


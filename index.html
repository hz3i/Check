<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Game Score</title>

<style>
:root{
  color-scheme: dark;
  --bg:#000;
  --card:#111;
  --border:#333;
  --btn:#1e88e5;
  --red:#c62828;     /* TOP */
  --green:#2e7d32;   /* LOW */
  --muted:#aaa;
}
body{ margin:0; font-family:system-ui,-apple-system; background:var(--bg); color:#fff; }
h1{ margin:16px; }
.card{ border:1px solid var(--border); border-radius:16px; padding:16px; margin:16px; background:var(--card); }
.row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
button,input{
  padding:10px 14px; border-radius:12px; border:1px solid var(--border);
  background:#222; color:#fff; font-size:15px;
}
button.primary{ background:var(--btn); border:none; font-weight:700; }
button:active{ opacity:.85; }
input[type="number"]{ width:70px; text-align:center; }
input[type="text"]{ width:140px; }
.small{ font-size:13px; color:var(--muted); margin:6px 0 0; }
table{ width:100%; border-collapse:collapse; margin-top:12px; }
th,td{ padding:10px; border-bottom:1px solid var(--border); }
td.nameCell{ cursor:pointer; }
tr.top{ background:var(--red); }   /* TOP = RED */
tr.low{ background:var(--green); } /* LOW = GREEN */
tr.out{ opacity:.35; }
.history{ font-size:13px; color:var(--muted); margin-top:10px; line-height:1.4; }
.pill{ display:inline-block; padding:2px 8px; border:1px solid #666; border-radius:999px; font-size:12px; margin-inline-start:8px; opacity:.9; }

.toggle{
  display:flex; align-items:center; gap:8px;
  padding:8px 10px; border:1px solid var(--border); border-radius:12px; background:#151515;
}
.status{
  padding:6px 10px; border:1px solid var(--border); border-radius:999px;
  background:#151515; font-size:12px; color:var(--muted);
}
</style>
</head>

<body>
<h1 id="title">ğŸ® Game Score</h1>

<div class="card" id="setupCard">
  <div class="row">
    <span id="lblPlayers">Players</span>
    <input id="playersCount" type="number" min="2" max="10" value="2">
    <button class="primary" id="btnStart">Start / New Game</button>
  </div>

  <div class="row" style="margin-top:10px">
    <span id="lblLang">Language</span>
    <button id="btnAR">AR</button>
    <button id="btnEN">EN</button>
  </div>

  <p class="small" id="tip">Tip: This app auto-saves.</p>
</div>

<div class="card" id="gameCard" style="display:none">

  <div class="row">
    <button id="btnAddRound">â• Add Round</button>
    <button id="btnAddPlayer">ğŸ‘¤ Add Player</button>
    <button id="btnNewGame" class="primary">ğŸ†• New Game</button>
    <button id="btnGoSetup">âš™ï¸ Setup</button>
    <button id="btnReset">ğŸ”„ Reset</button>
  </div>

  <div class="row" style="margin-top:10px">
    <span id="lblKick">Kick-out at</span>
    <input id="target" type="number" min="1" value="100">
    <span class="small" id="lblHint">Players become OUT when total â‰¥ target.</span>
  </div>

  <div class="row" style="margin-top:10px">
    <div class="toggle">
      <input id="doubleToggle" type="checkbox">
      <label id="lblDouble" for="doubleToggle" style="cursor:pointer">x2 Double scores</label>
    </div>

    <div class="toggle">
      <span id="lblRoom">Room</span>
      <input id="roomInput" type="text" placeholder="majlis1" autocapitalize="none" autocomplete="off">
      <button id="btnSetRoom">Set</button>
    </div>

    <div class="status" id="syncStatus">Local</div>
  </div>

  <table id="table">
    <thead>
      <tr>
        <th id="thPlayer">Player</th>
        <th id="thTotal">Total</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div class="history" id="history"></div>
</div>

<script>
/* =============================
   Firebase (Realtime Database)
   ============================= */
// IMPORTANT: GitHub Pages needs CDN scripts (no "import").
const FIREBASE_ENABLED = true; // keep true
const firebaseConfig = {
  apiKey: "AIzaSyC0twO6-07rT8NNwqVOlLDpwRIakjC122Y",
  authDomain: "ceck-21719.firebaseapp.com",
  databaseURL: "https://ceck-21719-default-rtdb.firebaseio.com",
  projectId: "ceck-21719",
  storageBucket: "ceck-21719.firebasestorage.app",
  messagingSenderId: "747335920443",
  appId: "1:747335920443:web:d65ff3f8ed4b801e3a651e",
  measurementId: "G-N68P7BHP86"
};

let firebaseReady = false;
let firebaseDb = null;

/* =============================
   App State
   ============================= */
const KEY_LOCAL = "gameScore_v3_local";
const KEY_ROOM  = "gameScore_room";
const KEY_CID   = "gameScore_clientId";

let clientId = localStorage.getItem(KEY_CID);
if(!clientId){
  clientId = Math.random().toString(36).slice(2) + Date.now().toString(36);
  localStorage.setItem(KEY_CID, clientId);
}

let room = localStorage.getItem(KEY_ROOM) || "";
let isApplyingRemote = false;
let lastWriteTs = 0;
let lastAppliedRemoteTs = 0;
let roomListenerRef = null;

let state = {
  lang: "ar",
  names: [],
  totals: [],
  out: [],
  history: [],
  target: 100,
  double: false
};

const I18N = {
  ar: {
    title: "ğŸ® Ù†Ù‚Ø§Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©",
    players: "Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†",
    start: "Ø§Ø¨Ø¯Ø£ / Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©",
    lang: "Ø§Ù„Ù„ØºØ©",
    tip: "Ù…Ù„Ø§Ø­Ø¸Ø©: Ø§Ù„Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù‡Ø§Ø².",
    addRound: "â• Ø¥Ø¶Ø§ÙØ© Ø¬ÙˆÙ„Ø©",
    addPlayer: "ğŸ‘¤ Ø¥Ø¶Ø§ÙØ© Ù„Ø§Ø¹Ø¨",
    newGame: "ğŸ†• Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©",
    setup: "âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
    reset: "ğŸ”„ ØªØµÙÙŠØ±",
    kick: "Ø§Ù„Ø¥Ù‚ØµØ§Ø¡ Ø¹Ù†Ø¯",
    hint: "ÙŠØµØ¨Ø­ Ø§Ù„Ù„Ø§Ø¹Ø¨ OUT Ø¹Ù†Ø¯Ù…Ø§ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ â‰¥ Ø§Ù„Ù‡Ø¯Ù.",
    thPlayer: "Ø§Ù„Ù„Ø§Ø¹Ø¨",
    thTotal: "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹",
    editName: "ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø§Ø³Ù…",
    pointsFor: "Ù†Ù‚Ø§Ø· Ø§Ù„Ø¬ÙˆÙ„Ø© Ù„Ù€",
    out: "OUT",
    round: "Ø¬ÙˆÙ„Ø©",
    confirmReset: "ØªØµÙÙŠØ± ÙƒÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø¬Ù…ÙŠØ¹ INØŸ",
    confirmNew: "Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©ØŸ (Ø³ÙŠØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø­Ø§Ù„ÙŠ)",
    maxPlayers: "Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 10 Ù„Ø§Ø¹Ø¨ÙŠÙ†.",
    double: "x2 Ù…Ø¶Ø§Ø¹ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø·",
    room: "Ø§Ù„ØºØ±ÙØ©",
    set: "ØªØ¹ÙŠÙŠÙ†",
    local: "Ù…Ø­Ù„ÙŠ",
    live: "Ù…Ø¨Ø§Ø´Ø±",
    firebaseFail: "âš ï¸ ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Firebase â€” Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙŠØ¹Ù…Ù„ Ù…Ø­Ù„ÙŠÙ‹Ø§."
  },
  en: {
    title: "ğŸ® Game Score",
    players: "Players",
    start: "Start / New Game",
    lang: "Language",
    tip: "Tip: This app auto-saves.",
    addRound: "â• Add Round",
    addPlayer: "ğŸ‘¤ Add Player",
    newGame: "ğŸ†• New Game",
    setup: "âš™ï¸ Setup",
    reset: "ğŸ”„ Reset",
    kick: "Kick-out at",
    hint: "Players become OUT when total â‰¥ target.",
    thPlayer: "Player",
    thTotal: "Total",
    editName: "Edit name",
    pointsFor: "Round points for",
    out: "OUT",
    round: "Round",
    confirmReset: "Reset all totals and set everyone IN?",
    confirmNew: "Start a new game? (clears current)",
    maxPlayers: "Max players is 10.",
    double: "x2 Double scores",
    room: "Room",
    set: "Set",
    local: "Local",
    live: "Live",
    firebaseFail: "âš ï¸ Firebase failed to load â€” app runs locally."
  }
};

function t(k){ return I18N[state.lang][k] || k; }
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
}

/* =============================
   UI Text / Language
   ============================= */
function applyLang(){
  document.documentElement.lang = state.lang;
  document.documentElement.dir  = (state.lang === "ar") ? "rtl" : "ltr";

  title.textContent      = t("title");
  lblPlayers.textContent = t("players");
  btnStart.textContent   = t("start");
  lblLang.textContent    = t("lang");
  tip.textContent        = t("tip");

  btnAddRound.textContent  = t("addRound");
  btnAddPlayer.textContent = t("addPlayer");
  btnNewGame.textContent   = t("newGame");
  btnGoSetup.textContent   = t("setup");
  btnReset.textContent     = t("reset");

  lblKick.textContent   = t("kick");
  lblHint.textContent   = t("hint");
  thPlayer.textContent  = t("thPlayer");
  thTotal.textContent   = t("thTotal");

  lblDouble.textContent = t("double");
  lblRoom.textContent   = t("room");
  btnSetRoom.textContent= t("set");

  setSyncBadge();
}

function setSyncBadge(msg){
  if(!room || !firebaseReady){
    syncStatus.textContent = msg || t("local");
  }else{
    syncStatus.textContent = msg || t("live") + `: ${room}`;
  }
}

/* =============================
   Local Save/Load
   ============================= */
function saveLocal(){
  state.target = Math.max(1, Math.floor(+target.value || 100));
  state.double = !!doubleToggle.checked;
  localStorage.setItem(KEY_LOCAL, JSON.stringify(state));
}

function loadLocal(){
  try{
    const raw = localStorage.getItem(KEY_LOCAL);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(!s) return;
    state = { ...state, ...s };
  }catch{}
}

/* =============================
   Firebase helpers (CDN)
   ============================= */
function loadScript(src){
  return new Promise((resolve,reject)=>{
    const s = document.createElement("script");
    s.src = src;
    s.async = true;
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

async function ensureFirebase(){
  if(!FIREBASE_ENABLED) return false;
  if(firebaseReady && firebaseDb) return true;

  try{
    await loadScript("https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js");
    await loadScript("https://www.gstatic.com/firebasejs/10.12.5/firebase-database-compat.js");

    // init (compat)
    if(!firebase.apps || firebase.apps.length === 0){
      firebase.initializeApp(firebaseConfig);
    }
    firebaseDb = firebase.database();
    firebaseReady = true;
    return true;
  }catch(e){
    firebaseReady = false;
    firebaseDb = null;
    setSyncBadge(t("local"));
    alert(t("firebaseFail"));
    return false;
  }
}

function roomStatePath(r){ return `rooms/${String(r).trim().toLowerCase()}/state`; }

function writeRemote(){
  if(isApplyingRemote) return;
  if(!firebaseReady || !firebaseDb || !room) return;

  const payload = {
    ...state,
    target: Math.max(1, Math.floor(+target.value || state.target || 100)),
    double: !!doubleToggle.checked,
    _ts: Date.now(),
    _by: clientId
  };

  lastWriteTs = payload._ts;

  firebaseDb.ref(roomStatePath(room)).set(payload).catch(()=>{});
  setSyncBadge(t("live") + `: ${room}`);
}

function startRoomListener(){
  if(!firebaseReady || !firebaseDb || !room) return;

  // remove old
  if(roomListenerRef){
    roomListenerRef.off();
    roomListenerRef = null;
  }

  const ref = firebaseDb.ref(roomStatePath(room));
  roomListenerRef = ref;

  ref.on("value", snap=>{
    const remote = snap.val();
    if(!remote) return;

    // ignore our own latest write
    if(remote._by === clientId && remote._ts && remote._ts <= lastWriteTs) return;

    // ignore older remote updates
    if(remote._ts && remote._ts <= lastAppliedRemoteTs) return;

    lastAppliedRemoteTs = remote._ts || Date.now();

    // apply
    isApplyingRemote = true;
    const { _ts, _by, ...clean } = remote;

    // keep language local preference if remote missing
    state = { ...state, ...clean };

    // sync UI controls
    target.value = state.target || 100;
    doubleToggle.checked = !!state.double;

    saveLocal();
    render();
    isApplyingRemote = false;

    setSyncBadge(t("live") + `: ${room}`);
  });

  setSyncBadge(t("live") + `: ${room}`);
}

/* =============================
   Game logic
   ============================= */
function showSetup(){
  setupCard.style.display = "";
  gameCard.style.display  = "none";
  applyLang();
}

function showGame(){
  setupCard.style.display = "none";
  gameCard.style.display  = "";
  target.value = state.target || 100;
  doubleToggle.checked = !!state.double;
  roomInput.value = room || "";
  applyLang();
  render();
}

function newGame(n){
  state.names = Array.from({length:n}, (_,i)=>`Player ${i+1}`);
  state.totals = Array(n).fill(0);
  state.out = Array(n).fill(false);
  state.history = [];
  state.target = Math.max(1, Math.floor(+target.value || state.target || 100));
  saveLocal();
  writeRemote();
}

function computeTopLow(){
  const inIdx = state.totals.map((_,i)=>i).filter(i=>!state.out[i]);
  if(inIdx.length === 0) return { top:-1, low:-1, allEqual:true };

  let top = inIdx[0], low = inIdx[0];
  for(const i of inIdx){
    if(state.totals[i] > state.totals[top]) top = i;
    if(state.totals[i] < state.totals[low]) low = i;
  }
  const allEqual = inIdx.every(i => state.totals[i] === state.totals[inIdx[0]]);
  return { top, low, allEqual };
}

function render(){
  const tbody = document.querySelector("#table tbody");
  tbody.innerHTML = "";

  const {top, low, allEqual}s = computeTopLow(); // typo guard? we'll do below properly
}

function render(){
  const tbody = document.querySelector("#table tbody");
  tbody.innerHTML = "";

  const {top, low, allEqual} = computeTopLow();

  state.names.forEach((name,i)=>{
    const tr = document.createElement("tr");

    if(state.out[i]) tr.classList.add("out");
    if(!state.out[i] && !allEqual && i===top) tr.classList.add("top");   // TOP = RED
    if(!state.out[i] && !allEqual && i===low) tr.classList.add("low");   // LOW = GREEN

    const tdName = document.createElement("td");
    tdName.className = "nameCell";
    tdName.innerHTML = `${escapeHtml(name)}${state.out[i] ? ` <span class="pill">${t("out")}</span>` : ""}`;
    tdName.onclick = ()=>editName(i);

    const tdTotal = document.createElement("td");
    tdTotal.textContent = String(state.totals[i]);

    tr.appendChild(tdName);
    tr.appendChild(tdTotal);
    tbody.appendChild(tr);
  });

  history.innerHTML = state.history.slice(0,12).map(h=>"â€¢ "+escapeHtml(h)).join("<br>");
}

function editName(i){
  const val = prompt(t("editName"), state.names[i]);
  if(val === null) return;
  const name = val.trim();
  if(name) state.names[i] = name;
  saveLocal();
  render();
  writeRemote();
}

function addPlayer(){
  if(state.names.length >= 10) return alert(t("maxPlayers"));
  const val = prompt(t("addPlayer"), `Player ${state.names.length+1}`);
  if(val === null) return;
  const name = val.trim() || `Player ${state.names.length+1}`;
  state.names.push(name);
  state.totals.push(0);
  state.out.push(false);
  saveLocal();
  render();
  writeRemote();
}

function addRound(){
  const inIdx = state.names.map((_,i)=>i).filter(i=>!state.out[i]);
  if(inIdx.length === 0) return;

  state.target = Math.max(1, Math.floor(+target.value || 100));
  state.double = !!doubleToggle.checked;

  const changes = [];
  for(const i of inIdx){
    const v = prompt(`${t("pointsFor")} ${state.names[i]}`, "0");
    if(v === null) return;

    let pts = Number(v);
    if(!Number.isFinite(pts)) pts = 0;

    // âœ… Double option
    if(state.double) pts = pts * 2;

    state.totals[i] += pts;
    changes.push(`${state.names[i]} +${pts}`);

    if(state.totals[i] >= state.target) state.out[i] = true;
  }

  state.history.unshift(`${t("round")}: ${changes.join(", ")}`);
  saveLocal();
  render();
  writeRemote();
}

function resetTotals(){
  if(!confirm(t("confirmReset"))) return;
  state.totals = state.totals.map(()=>0);
  state.out = state.out.map(()=>false);
  state.history = [];
  saveLocal();
  render();
  writeRemote();
}

function startFromSetup(){
  const n = Math.max(2, Math.min(10, Math.floor(+playersCount.value || 2)));
  newGame(n);

  // optional: rename players quickly
  for(let i=0;i<state.names.length;i++){
    const v = prompt(`Name for ${state.names[i]}`, state.names[i]);
    if(v === null) break;
    const name = v.trim();
    if(name) state.names[i] = name;
  }

  saveLocal();
  showGame();
  writeRemote();
}

function newGameButton(){
  if(!confirm(t("confirmNew"))) return;
  showSetup();
}

/* =============================
   Room / Live Share
   ============================= */
async function setRoom(){
  const r = (roomInput.value || "").trim();
  if(!r){
    room = "";
    localStorage.removeItem(KEY_ROOM);
    setSyncBadge(t("local"));
    if(roomListenerRef){ roomListenerRef.off(); roomListenerRef=null; }
    return;
  }

  room = r.toLowerCase();
  localStorage.setItem(KEY_ROOM, room);

  const ok = await ensureFirebase();
  if(!ok){
    setSyncBadge(t("local"));
    return;
  }

  startRoomListener();

  // if room is empty on server, publish current local state as initial
  firebaseDb.ref(roomStatePath(room)).get().then(snap=>{
    if(!snap.exists()){
      writeRemote();
    }
  }).catch(()=>{});
}

/* =============================
   Wire buttons
   ============================= */
btnStart.onclick = startFromSetup;
btnAddRound.onclick = addRound;
btnAddPlayer.onclick = addPlayer;
btnReset.onclick = resetTotals;
btnNewGame.onclick = newGameButton;
btnGoSetup.onclick = showSetup;

btnAR.onclick = ()=>{ state.lang="ar"; saveLocal(); applyLang(); render(); };
btnEN.onclick = ()=>{ state.lang="en"; saveLocal(); applyLang(); render(); };

target.onchange = ()=>{
  state.target = Math.max(1, Math.floor(+target.value || 100));
  // re-evaluate OUT based on new target
  state.out = state.totals.map(x => x >= state.target);
  saveLocal();
  render();
  writeRemote();
};

doubleToggle.onchange = ()=>{
  state.double = !!doubleToggle.checked;
  saveLocal();
  writeRemote();
};

btnSetRoom.onclick = setRoom;

/* =============================
   Boot
   ============================= */
loadLocal();
applyLang();

if(state.names && state.names.length >= 2) showGame();
else showSetup();

roomInput.value = room || "";
if(room){
  // attempt live share automatically
  ensureFirebase().then(ok=>{
    if(ok){
      startRoomListener();
      setSyncBadge(t("live")+`: ${room}`);
    }else{
      setSyncBadge(t("local"));
    }
  });
}else{
  setSyncBadge(t("local"));
}
</script>
</body>
</html>
